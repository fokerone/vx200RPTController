<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mapa APRS - VX200 RPT Controller</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css" />
    <style>
        #map {
            height: 70vh;
            width: 100%;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            position: relative;
        }
        .distance-widget {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(255, 255, 255, 0.95);
            padding: 8px 12px;
            border-radius: 6px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
            z-index: 1000;
            font-size: 0.85em;
            font-weight: 500;
            color: #495057;
            border-left: 3px solid #007bff;
            min-width: 140px;
        }
        .distance-widget .distance-value {
            color: #007bff;
            font-weight: bold;
        }
        .info-panel {
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            padding: 15px;
            margin-bottom: 20px;
        }
        .station-info {
            padding: 10px;
            background: #f8f9fa;
            border-radius: 5px;
            margin-bottom: 10px;
        }
        .status-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
        }
        .status-connected { background-color: #28a745; }
        .status-disconnected { background-color: #dc3545; }
        .beacon-status { 
            font-size: 0.9em;
            color: #6c757d;
        }
        .position-list {
            max-height: 300px;
            overflow-y: auto;
        }
        .position-item {
            padding: 8px 12px;
            border-bottom: 1px solid #e9ecef;
            cursor: pointer;
        }
        .position-item:hover {
            background-color: #f8f9fa;
        }
        .callsign {
            font-weight: bold;
            color: #007bff;
        }
        .timestamp {
            font-size: 0.8em;
            color: #6c757d;
        }
        .coordinates {
            font-size: 0.9em;
            color: #495057;
        }
        
        /* Estilo para el scroll del panel de detalles */
        #stationDetails::-webkit-scrollbar {
            width: 8px;
        }
        
        #stationDetails::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 4px;
        }
        
        #stationDetails::-webkit-scrollbar-thumb {
            background: #007bff;
            border-radius: 4px;
        }
        
        #stationDetails::-webkit-scrollbar-thumb:hover {
            background: #0056b3;
        }
        
        /* Mejorar espaciado en el panel de detalles */
        .station-detail-header {
            position: sticky;
            top: 0;
            background: white;
            padding-bottom: 10px;
            border-bottom: 1px solid #e9ecef;
            margin-bottom: 15px;
            z-index: 10;
        }
    </style>
</head>
<body>
    <nav class="navbar navbar-dark bg-primary">
        <div class="container-fluid">
            <span class="navbar-brand mb-0 h1">üì° VX200 RPT Controller - Mapa APRS</span>
            <div class="d-flex align-items-center">
                <a href="/" class="btn btn-outline-light btn-sm me-3">‚Üê Panel Principal</a>
                <span class="status-indicator" id="connectionStatus"></span>
                <span id="connectionText">Desconectado</span>
            </div>
        </div>
    </nav>

    <div class="container-fluid mt-3">
        <div class="row">
            <div class="col-md-8">
                <div class="info-panel">
                    <h5>üó∫Ô∏è Mapa de Posiciones APRS</h5>
                    <div id="map">
                        <div class="distance-widget" id="distanceWidget">
                            üìè Estaci√≥n m√°s lejana: <span class="distance-value" id="maxDistanceValue">0 km</span>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="col-md-4">
                <!-- Estado del Sistema APRS -->
                <div class="info-panel">
                    <h5>üì° Estado APRS</h5>
                    <div id="aprsStatus">
                        <div class="d-flex justify-content-between">
                            <span>TNC:</span>
                            <span id="tncStatus" class="text-muted">Desconocido</span>
                        </div>
                        <div class="d-flex justify-content-between">
                            <span>Callsign:</span>
                            <span id="callsign" class="text-muted">-</span>
                        </div>
                        <div class="d-flex justify-content-between">
                            <span>Beacons enviados:</span>
                            <span id="beaconsSent" class="text-muted">0</span>
                        </div>
                        <div class="d-flex justify-content-between">
                            <span>Posiciones recibidas:</span>
                            <span id="positionsReceived" class="text-muted">0</span>
                        </div>
                    </div>
                    <div class="mt-3">
                        <button class="btn btn-primary btn-sm" onclick="sendManualBeacon()">Enviar Beacon</button>
                        <button class="btn btn-secondary btn-sm" onclick="refreshMap()">Actualizar</button>
                    </div>
                </div>

                <!-- Filtros de Fecha -->
                <div class="info-panel">
                    <h5>üîç Filtros</h5>
                    <div class="mb-3">
                        <label class="form-label">Mostrar estaciones:</label>
                        <select class="form-select form-select-sm" id="dateFilter" onchange="applyDateFilter()">
                            <option value="all">Todas las fechas</option>
                            <option value="today" selected>Solo hoy</option>
                            <option value="yesterday">Solo ayer</option>
                            <option value="last7days">√öltimos 7 d√≠as</option>
                        </select>
                    </div>
                    <div class="mb-3">
                        <label class="form-label">Rango de fechas:</label>
                        <div class="row">
                            <div class="col-6">
                                <input type="date" class="form-control form-control-sm" id="startDate" onchange="applyCustomFilter()">
                            </div>
                            <div class="col-6">
                                <input type="date" class="form-control form-control-sm" id="endDate" onchange="applyCustomFilter()">
                            </div>
                        </div>
                    </div>
                    <div class="small text-muted" id="filterStats">
                        Mostrando todas las estaciones
                    </div>
                </div>

                <!-- Lista de Estaciones -->
                <div class="info-panel">
                    <h5>üìã Estaciones Recibidas</h5>
                    <div class="position-list" id="positionsList">
                        <div class="text-center text-muted p-3">
                            No hay posiciones recibidas
                        </div>
                    </div>
                </div>

                <!-- Informaci√≥n Detallada -->
                <div class="info-panel" id="detailPanel" style="display: none;">
                    <h5>‚ÑπÔ∏è Informaci√≥n de Estaci√≥n</h5>
                    <div id="stationDetails" style="max-height: 400px; overflow-y: auto; padding-right: 5px;"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Scripts -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"></script>
    <script src="/socket.io/socket.io.js"></script>
    
    <script>
        // Variables globales
        let map;
        let socket;
        let markers = {};
        let repeaterMarker;
        let positions = [];
        let coverageCircle = null;
        let maxDistance = 0;
        
        // Configuraci√≥n del repetidor (deber√≠an venir del servidor)
        const REPEATER_CONFIG = {
            callsign: 'YOSHUA',
            lat: -32.9082647,
            lon: -68.8162689,
            elevation: 775,
            name: 'VX200 RPT Controller - Guaymall√©n'
        };
        
        // Funci√≥n para calcular distancia (Haversine)
        function calculateDistance(lat1, lon1, lat2, lon2) {
            const R = 6371; // Radio de la Tierra en km
            const dLat = toRadians(lat2 - lat1);
            const dLon = toRadians(lon2 - lon1);
            const a = 
                Math.sin(dLat/2) * Math.sin(dLat/2) +
                Math.cos(toRadians(lat1)) * Math.cos(toRadians(lat2)) * 
                Math.sin(dLon/2) * Math.sin(dLon/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            return R * c;
        }
        
        function toRadians(degrees) {
            return degrees * (Math.PI/180);
        }
        
        // Inicializar aplicaci√≥n
        document.addEventListener('DOMContentLoaded', function() {
            initializeMap();
            initializeSocket();
            loadInitialDataWithFilters();
            loadInitialAPRSStatus(); // Cargar estado APRS inicial
            
            // Asegurar que el filtro "today" est√© seleccionado (despu√©s de que se carguen los datos)
            setTimeout(() => {
                document.getElementById('dateFilter').value = 'today';
            }, 300);
        });
        
        // Inicializar mapa
        function initializeMap() {
            map = L.map('map').setView([REPEATER_CONFIG.lat, REPEATER_CONFIG.lon], 12); // Zoom inicial m√°s cercano
            
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '¬© OpenStreetMap contributors'
            }).addTo(map);
            
            // Agregar marcador del repetidor
            repeaterMarker = L.marker([REPEATER_CONFIG.lat, REPEATER_CONFIG.lon], {
                icon: L.icon({
                    iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-red.png',
                    shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png',
                    iconSize: [25, 41],
                    iconAnchor: [12, 41],
                    popupAnchor: [1, -34],
                    shadowSize: [41, 41]
                })
            }).addTo(map);
            
            repeaterMarker.bindPopup(`
                <b>${REPEATER_CONFIG.callsign}</b><br>
                ${REPEATER_CONFIG.name}<br>
                <small>Repetidor Base</small>
            `);
        }
        
        // Inicializar WebSocket
        function initializeSocket() {
            socket = io();
            
            socket.on('connect', function() {
                updateConnectionStatus(true);
                console.log('Conectado al servidor');
            });
            
            socket.on('disconnect', function() {
                updateConnectionStatus(false);
                console.log('Desconectado del servidor');
            });
            
            socket.on('aprs_position', function(data) {
                console.log('Nueva posici√≥n APRS:', data);
                addPositionWithFilter(data.data);
            });
            
            socket.on('aprs_beacon', function(data) {
                console.log('Beacon APRS enviado:', data);
                updateBeaconCount();
            });
            
            socket.on('aprs_status', function(data) {
                console.log('Estado APRS actualizado:', data);
                updateAPRSStatus(data.data);
            });
        }
        
        // Cargar datos iniciales
        async function loadInitialData() {
            try {
                // Cargar posiciones existentes
                const positionsResponse = await fetch('/api/aprs/positions');
                if (positionsResponse.ok) {
                    const positionsData = await positionsResponse.json();
                    if (positionsData.success) {
                        positions = positionsData.data;
                        renderPositions();
                        // Actualizar marcadores de posiciones existentes
                        positions.forEach(pos => updatePositionMarker(pos));
                        // Actualizar c√≠rculo de cobertura despu√©s de cargar las posiciones
                        updateCoverageCircle();
                    }
                }
                
                // Cargar estado APRS
                const statusResponse = await fetch('/api/aprs/status');
                if (statusResponse.ok) {
                    const statusData = await statusResponse.json();
                    if (statusData.success) {
                        updateAPRSStatus(statusData.data);
                    }
                }
            } catch (error) {
                console.error('Error cargando datos iniciales:', error);
            }
        }
        
        // Actualizar estado de conexi√≥n
        function updateConnectionStatus(connected) {
            const statusElement = document.getElementById('connectionStatus');
            const textElement = document.getElementById('connectionText');
            
            if (connected) {
                statusElement.className = 'status-indicator status-connected';
                textElement.textContent = 'Conectado';
            } else {
                statusElement.className = 'status-indicator status-disconnected';
                textElement.textContent = 'Desconectado';
            }
        }
        
        // Agregar nueva posici√≥n
        function addPosition(position) {
            console.log('üì° Nueva posici√≥n recibida:', position);
            
            // Buscar si ya existe
            const existingIndex = positions.findIndex(p => p.callsign === position.callsign);
            
            if (existingIndex >= 0) {
                console.log(`üîÑ Actualizando posici√≥n existente: ${position.callsign}`);
                positions[existingIndex] = position;
            } else {
                console.log(`üÜï Nueva estaci√≥n: ${position.callsign}`);
                positions.push(position);
            }
            
            // Actualizar toda la vista
            renderPositions();
            updatePositionMarker(position);
            updateCoverageCircle();
            
            console.log(`üìä Total posiciones: ${positions.length}`);
        }
        
        // Renderizar lista de posiciones
        function renderPositions() {
            const listContainer = document.getElementById('positionsList');
            
            if (positions.length === 0) {
                listContainer.innerHTML = '<div class="text-center text-muted p-3">No hay posiciones recibidas</div>';
                return;
            }
            
            // Agrupar por callsign y mostrar la m√°s reciente de cada uno primero
            const groupedByCallsign = {};
            positions.forEach(pos => {
                if (!groupedByCallsign[pos.callsign]) {
                    groupedByCallsign[pos.callsign] = [];
                }
                groupedByCallsign[pos.callsign].push(pos);
            });
            
            // Ordenar cada grupo por timestamp y tomar la m√°s reciente para el listado principal
            const sortedPositions = Object.values(groupedByCallsign).map(group => {
                const sorted = group.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
                return sorted[0]; // Tomar la m√°s reciente de cada callsign
            }).sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
            
            const html = sortedPositions.map(pos => {
                const timeAgo = getTimeAgo(new Date(pos.timestamp));
                const distance = pos.distance || calculateDistance(REPEATER_CONFIG.lat, REPEATER_CONFIG.lon, pos.lat, pos.lon);
                const allPositionsCount = groupedByCallsign[pos.callsign].length;
                
                return `
                    <div class="position-item" onclick="showStationDetails('${pos.callsign}')">
                        <div class="callsign">${pos.callsign}${allPositionsCount > 1 ? ` (${allPositionsCount} ubicaciones)` : ''}</div>
                        <div class="coordinates">${pos.lat.toFixed(4)}, ${pos.lon.toFixed(4)} ${allPositionsCount > 1 ? '(m√°s reciente)' : ''}</div>
                        <div class="text-info" style="font-size: 0.85em;">üìè ${distance.toFixed(2)} km</div>
                        <div class="timestamp">${timeAgo}</div>
                        ${pos.comment ? `<div class="text-muted" style="font-size: 0.8em;">${pos.comment}</div>` : ''}
                    </div>
                `;
            }).join('');
            
            listContainer.innerHTML = html;
        }
        
        // Actualizar marcador en el mapa
        function updatePositionMarker(position) {
            // Usar key √∫nica para cada ubicaci√≥n diferente
            const locationId = position.locationId || `${position.lat}_${position.lon}`;
            const key = `${position.callsign}_${locationId}`;
            
            // Verificar si el marcador ya existe para evitar duplicados
            if (markers[key]) {
                console.log(`Marcador ya existe para ${key}, omitiendo creaci√≥n`);
                return;
            }
            
            // Crear nuevo marcador
            const marker = L.marker([position.lat, position.lon], {
                icon: L.icon({
                    iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-blue.png',
                    shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png',
                    iconSize: [25, 41],
                    iconAnchor: [12, 41],
                    popupAnchor: [1, -34],
                    shadowSize: [41, 41]
                })
            }).addTo(map);
            
            const timeAgo = getTimeAgo(new Date(position.timestamp));
            const distance = position.distance || calculateDistance(REPEATER_CONFIG.lat, REPEATER_CONFIG.lon, position.lat, position.lon);
            marker.bindPopup(`
                <b>${position.callsign}</b><br>
                ${position.lat.toFixed(4)}, ${position.lon.toFixed(4)}<br>
                <span style="color: #007bff;">üìè ${distance.toFixed(2)} km</span><br>
                <small>${timeAgo}</small>
                ${position.comment ? `<br><i>${position.comment}</i>` : ''}
                ${position.symbol ? `<br><small>${position.symbol}</small>` : ''}
            `);
            
            // Guardar marcador con key √∫nica
            markers[key] = marker;
            
            console.log(`Marcador creado: ${key} en ${position.lat.toFixed(4)}, ${position.lon.toFixed(4)}`);
        }
        
        // Mostrar detalles de estaci√≥n
        function showStationDetails(callsign) {
            const stationPositions = positions.filter(p => p.callsign === callsign);
            if (stationPositions.length === 0) return;
            
            const detailPanel = document.getElementById('detailPanel');
            const detailsContainer = document.getElementById('stationDetails');
            
            // Mostrar informaci√≥n de todas las ubicaciones de esta estaci√≥n
            const positionsHtml = stationPositions.map((position, index) => {
                const timeAgo = getTimeAgo(new Date(position.timestamp));
                const distance = position.distance || calculateDistance(REPEATER_CONFIG.lat, REPEATER_CONFIG.lon, position.lat, position.lon);
                
                return `
                    <div class="station-info" style="margin-bottom: 10px; ${index === 0 ? 'border: 2px solid #007bff;' : ''}">
                        <h6>${position.callsign} ${index > 0 ? `(Ubicaci√≥n #${index + 1})` : '(M√°s reciente)'}</h6>
                        <div><strong>Ubicaci√≥n:</strong> ${position.lat.toFixed(6)}, ${position.lon.toFixed(6)}</div>
                        <div><strong>Distancia:</strong> <span style="color: #007bff;">üìè ${distance.toFixed(2)} km</span></div>
                        <div><strong>√öltima actualizaci√≥n:</strong> ${timeAgo}</div>
                        <div><strong>Timestamp:</strong> ${new Date(position.timestamp).toLocaleString()}</div>
                        ${position.comment ? `<div><strong>Comentario:</strong> ${position.comment}</div>` : ''}
                        ${position.symbol ? `<div><strong>S√≠mbolo:</strong> ${position.symbol}</div>` : ''}
                        <button onclick="focusOnPosition('${callsign}', ${position.lat}, ${position.lon})" class="btn btn-sm btn-outline-primary">
                            üìç Ver en mapa
                        </button>
                    </div>
                `;
            }).join('');
            
            detailsContainer.innerHTML = `
                <div class="station-detail-header">
                    <strong>üì° ${callsign}</strong> - ${stationPositions.length} ubicacion${stationPositions.length > 1 ? 'es' : ''} registrada${stationPositions.length > 1 ? 's' : ''}
                    <div style="font-size: 0.9em; color: #6c757d; margin-top: 5px;">
                        Haz clic en "üìç Ver en mapa" para navegar a cada ubicaci√≥n
                    </div>
                </div>
                <div style="padding-bottom: 10px;">
                    ${positionsHtml}
                </div>
            `;
            
            detailPanel.style.display = 'block';
            
            // Centrar en la posici√≥n m√°s reciente y ajustar zoom para ver todas las ubicaciones
            const mostRecent = stationPositions[0];
            focusOnPosition(callsign, mostRecent.lat, mostRecent.lon);
        }
        
        // Nueva funci√≥n para enfocar en una posici√≥n espec√≠fica
        function focusOnPosition(callsign, lat, lon) {
            // Centrar mapa en la posici√≥n con zoom cercano
            map.setView([lat, lon], 15, {
                animate: true,
                duration: 1.0
            });
            
            // Buscar y abrir popup del marcador correspondiente
            const locationId = `${lat}_${lon}`;
            const key = `${callsign}_${locationId}`;
            
            if (markers[key]) {
                markers[key].openPopup();
            } else {
                // Buscar por proximidad si no hay coincidencia exacta
                Object.keys(markers).forEach(markerKey => {
                    if (markerKey.startsWith(callsign + '_')) {
                        const marker = markers[markerKey];
                        const markerPos = marker.getLatLng();
                        // Verificar si es la posici√≥n correcta (tolerancia de 0.0001 grados ~10m)
                        if (Math.abs(markerPos.lat - lat) < 0.0001 && Math.abs(markerPos.lng - lon) < 0.0001) {
                            marker.openPopup();
                        }
                    }
                });
            }
        }
        
        // Actualizar estado APRS
        function updateAPRSStatus(status) {
            document.getElementById('tncStatus').textContent = status.tncConnected ? 'Conectado' : 'Desconectado';
            document.getElementById('callsign').textContent = status.config.callsign || '-';
            document.getElementById('beaconsSent').textContent = status.stats.beaconsSent || 0;
            document.getElementById('positionsReceived').textContent = status.stats.positionsReceived || 0;
            
            // Estado actualizado correctamente
            
            const tncElement = document.getElementById('tncStatus');
            tncElement.className = status.tncConnected ? 'text-success' : 'text-danger';
        }
        
        // Cargar estado APRS inicial
        function loadInitialAPRSStatus() {
            fetch('/api/aprs/status')
                .then(response => response.json())
                .then(data => {
                    if (data.success && data.data) {
                        updateAPRSStatus(data.data);
                        console.log('Estado APRS inicial cargado');
                    }
                })
                .catch(error => {
                    console.log('Error cargando estado APRS inicial:', error.message);
                });
        }
        
        // Actualizar contador de beacons enviados
        function updateBeaconCount() {
            // Simplemente hacer fetch del estado actual para obtener el contador actualizado
            fetch('/api/aprs/status')
                .then(response => response.json())
                .then(data => {
                    if (data.success && data.data) {
                        updateAPRSStatus(data.data);
                    }
                })
                .catch(error => {
                    console.log('Error actualizando contador de beacons:', error.message);
                });
        }
        
        // Enviar beacon manual
        async function sendManualBeacon() {
            try {
                const response = await fetch('/api/aprs/beacon', {
                    method: 'POST'
                });
                const data = await response.json();
                
                if (data.success) {
                    alert('Beacon APRS enviado correctamente');
                } else {
                    alert('Error: ' + data.message);
                }
            } catch (error) {
                console.error('Error enviando beacon:', error);
                alert('Error enviando beacon');
            }
        }
        
        // Limpiar todos los marcadores del mapa
        function clearAllMarkers() {
            // Limpiar todos los marcadores excepto el repetidor
            Object.keys(markers).forEach(key => {
                if (key !== 'repeater') {
                    const marker = markers[key];
                    if (Array.isArray(marker)) {
                        marker.forEach(m => map.removeLayer(m));
                    } else {
                        map.removeLayer(marker);
                    }
                    delete markers[key];
                }
            });
            
            // Limpiar c√≠rculo de cobertura (se recrea autom√°ticamente)
            if (coverageCircle) {
                map.removeLayer(coverageCircle);
                coverageCircle = null;
                maxDistance = 0; // Reset distancia m√°xima
            }
            
            console.log('Marcadores limpiados del mapa');
        }
        
        // Actualizar mapa
        function refreshMap() {
            console.log('Actualizando mapa - limpiando marcadores existentes...');
            clearAllMarkers();
            loadInitialDataWithFilters();
        }
        
        // Actualizar c√≠rculo de cobertura basado en estaciones m√°s lejanas
        function updateCoverageCircle(positionsToUse = null) {
            const activePositions = positionsToUse || positions;
            console.log(`üîµ updateCoverageCircle: ${activePositions.length} posiciones activas`);
            if (activePositions.length === 0) {
                // Si no hay posiciones, remover el c√≠rculo
                if (coverageCircle) {
                    map.removeLayer(coverageCircle);
                    coverageCircle = null;
                }
                maxDistance = 0;
                updateDistanceWidget();
                return;
            }
            
            // Encontrar la distancia m√°xima considerando todas las posiciones hist√≥ricas
            let newMaxDistance = 0;
            activePositions.forEach(pos => {
                const distance = pos.distance || calculateDistance(REPEATER_CONFIG.lat, REPEATER_CONFIG.lon, pos.lat, pos.lon);
                console.log(`üìè Estaci√≥n ${pos.callsign}: ${distance.toFixed(2)} km`);
                if (distance > newMaxDistance) {
                    newMaxDistance = distance;
                }
            });
            
            console.log(`üìè Distancia m√°xima calculada: ${newMaxDistance.toFixed(2)} km (actual: ${maxDistance.toFixed(2)} km)`);
            
            // Actualizar c√≠rculo (forzar recreaci√≥n cuando se usan posiciones filtradas)
            const forceUpdate = positionsToUse !== null; // Si se pasaron posiciones espec√≠ficas, forzar actualizaci√≥n
            if (Math.abs(newMaxDistance - maxDistance) > 0.1 || maxDistance === 0 || forceUpdate) {
                console.log(`üîµ Condici√≥n cumplida para crear c√≠rculo (forceUpdate: ${forceUpdate})`);
                maxDistance = newMaxDistance;
                
                // Remover c√≠rculo anterior
                if (coverageCircle) {
                    map.removeLayer(coverageCircle);
                }
                
                // Crear nuevo c√≠rculo con margen del 10%
                const radiusKm = maxDistance * 1.1;
                const radiusMeters = radiusKm * 1000;
                
                coverageCircle = L.circle([REPEATER_CONFIG.lat, REPEATER_CONFIG.lon], {
                    color: '#007bff',
                    fillColor: '#007bff',
                    fillOpacity: 0.1,
                    radius: radiusMeters,
                    weight: 2,
                    dashArray: '5, 5'
                }).addTo(map);
                
                coverageCircle.bindPopup(`
                    <b>üì° Rango de Recepci√≥n</b><br>
                    Radio: <span style="color: #007bff;">${radiusKm.toFixed(2)} km</span><br>
                    Estaci√≥n m√°s lejana: <span style="color: #007bff;">${maxDistance.toFixed(2)} km</span><br>
                    <small>Basado en ${activePositions.length} estacion${activePositions.length > 1 ? 'es' : ''} recibida${activePositions.length > 1 ? 's' : ''}</small>
                `);
                
                console.log(`üîµ C√≠rculo de cobertura creado: ${radiusKm.toFixed(2)} km con ${activePositions.length} estaciones`);
                
                // Ajustar zoom autom√°ticamente basado en el radio del c√≠rculo
                adjustMapZoom(radiusKm);
            } else {
                console.log(`‚ö†Ô∏è No se crea c√≠rculo: diferencia ${Math.abs(newMaxDistance - maxDistance).toFixed(2)} km < 0.1 km`);
            }
            
            // Actualizar widget de distancia
            updateDistanceWidget();
        }
        
        // Actualizar widget de distancia m√°xima
        function updateDistanceWidget() {
            const distanceWidget = document.getElementById('maxDistanceValue');
            if (distanceWidget) {
                if (maxDistance > 0) {
                    distanceWidget.textContent = `${maxDistance.toFixed(2)} km`;
                    document.getElementById('distanceWidget').style.display = 'block';
                } else {
                    document.getElementById('distanceWidget').style.display = 'none';
                }
            }
        }
        
        // Ajustar zoom del mapa basado en el radio del c√≠rculo de cobertura
        function adjustMapZoom(radiusKm) {
            // Calcular zoom apropiado basado en el radio
            // F√≥rmula: zoom m√°s alto para c√≠rculos peque√±os, zoom m√°s bajo para c√≠rculos grandes
            let targetZoom;
            
            if (radiusKm <= 0.5) {
                targetZoom = 15; // Muy cerca para c√≠rculos < 500m
            } else if (radiusKm <= 1.0) {
                targetZoom = 14; // Cerca para c√≠rculos < 1km
            } else if (radiusKm <= 2.0) {
                targetZoom = 13; // Medio para c√≠rculos < 2km
            } else if (radiusKm <= 5.0) {
                targetZoom = 12; // Moderado para c√≠rculos < 5km
            } else if (radiusKm <= 10.0) {
                targetZoom = 11; // Alejado para c√≠rculos < 10km
            } else {
                targetZoom = 10; // Muy alejado para c√≠rculos grandes
            }
            
            
            // Aplicar zoom suavemente
            map.setView([REPEATER_CONFIG.lat, REPEATER_CONFIG.lon], targetZoom, {
                animate: true,
                duration: 1.0
            });
        }

        // Utilidad para calcular tiempo transcurrido
        function getTimeAgo(date) {
            const now = new Date();
            const diffMs = now - date;
            const diffMins = Math.floor(diffMs / 60000);
            const diffHours = Math.floor(diffMins / 60);
            const diffDays = Math.floor(diffHours / 24);
            
            if (diffDays > 0) return `hace ${diffDays} d√≠a${diffDays > 1 ? 's' : ''}`;
            if (diffHours > 0) return `hace ${diffHours} hora${diffHours > 1 ? 's' : ''}`;
            if (diffMins > 0) return `hace ${diffMins} minuto${diffMins > 1 ? 's' : ''}`;
            return 'hace menos de 1 minuto';
        }

        // Variables para filtros
        let allPositions = []; // Almacenar todas las posiciones sin filtrar
        let currentFilter = 'today';

        // Aplicar filtro por fecha predefinido
        function applyDateFilter() {
            const filterSelect = document.getElementById('dateFilter');
            if (!filterSelect) {
                console.log('Filtro no disponible a√∫n, reintentando...');
                setTimeout(applyDateFilter, 100);
                return;
            }
            const filterValue = filterSelect.value;
            currentFilter = filterValue;
            
            // Limpiar campos de fecha personalizados
            document.getElementById('startDate').value = '';
            document.getElementById('endDate').value = '';
            
            let filteredPositions = [];
            const now = new Date();
            const todayStart = new Date(now.getFullYear(), now.getMonth(), now.getDate());
            const yesterdayStart = new Date(todayStart);
            yesterdayStart.setDate(yesterdayStart.getDate() - 1);
            const last7DaysStart = new Date(todayStart);
            last7DaysStart.setDate(last7DaysStart.getDate() - 7);
            
            switch (filterValue) {
                case 'all':
                    filteredPositions = [...allPositions];
                    break;
                case 'today':
                    filteredPositions = allPositions.filter(pos => {
                        const posDate = new Date(pos.timestamp);
                        return posDate >= todayStart;
                    });
                    break;
                case 'yesterday':
                    filteredPositions = allPositions.filter(pos => {
                        const posDate = new Date(pos.timestamp);
                        return posDate >= yesterdayStart && posDate < todayStart;
                    });
                    break;
                case 'last7days':
                    filteredPositions = allPositions.filter(pos => {
                        const posDate = new Date(pos.timestamp);
                        return posDate >= last7DaysStart;
                    });
                    break;
            }
            
            applyFilter(filteredPositions, getFilterDescription(filterValue));
        }

        // Aplicar filtro por rango de fechas personalizado
        function applyCustomFilter() {
            const startDate = document.getElementById('startDate').value;
            const endDate = document.getElementById('endDate').value;
            
            if (!startDate || !endDate) return;
            
            // Limpiar filtro predefinido
            document.getElementById('dateFilter').value = 'all';
            currentFilter = 'custom';
            
            const start = new Date(startDate + 'T00:00:00');
            const end = new Date(endDate + 'T23:59:59');
            
            const filteredPositions = allPositions.filter(pos => {
                const posDate = new Date(pos.timestamp);
                return posDate >= start && posDate <= end;
            });
            
            const description = `desde ${startDate} hasta ${endDate}`;
            applyFilter(filteredPositions, description);
        }

        // Aplicar filtro y actualizar la vista
        function applyFilter(filteredPositions, description) {
            // Actualizar la variable global positions
            positions = filteredPositions;
            
            // Limpiar marcadores existentes
            Object.values(markers).forEach(marker => {
                map.removeLayer(marker);
            });
            markers = {};
            
            // Agregar marcadores filtrados
            filteredPositions.forEach(pos => {
                updatePositionMarker(pos);
            });
            
            // Actualizar lista de estaciones
            renderPositions();
            
            // Actualizar estad√≠sticas del filtro
            updateFilterStats(filteredPositions, description);
            
            // Actualizar distancia m√°xima con datos filtrados
            updateMaxDistance(filteredPositions);
            
            // Actualizar c√≠rculo de cobertura con posiciones filtradas
            updateCoverageCircle(filteredPositions);
        }

        // Actualizar estad√≠sticas del filtro
        function updateFilterStats(filteredPositions, description) {
            const statsElement = document.getElementById('filterStats');
            const uniqueStations = new Set(filteredPositions.map(p => p.callsign)).size;
            
            statsElement.innerHTML = `
                Mostrando ${filteredPositions.length} posiciones de ${uniqueStations} estaciones<br>
                <small>${description}</small>
            `;
        }

        // Obtener descripci√≥n del filtro
        function getFilterDescription(filterValue) {
            switch (filterValue) {
                case 'all': return 'todas las fechas';
                case 'today': return 'solo hoy';
                case 'yesterday': return 'solo ayer';
                case 'last7days': return '√∫ltimos 7 d√≠as';
                default: return 'filtro personalizado';
            }
        }

        // Actualizar distancia m√°xima basada en posiciones filtradas
        function updateMaxDistance(filteredPositions) {
            if (filteredPositions.length === 0) {
                maxDistance = 0;
                document.getElementById('maxDistanceValue').textContent = '0 km';
                return;
            }
            
            maxDistance = Math.max(...filteredPositions.map(pos => 
                pos.distance || calculateDistance(REPEATER_CONFIG.lat, REPEATER_CONFIG.lon, pos.lat, pos.lon)
            ));
            
            const maxDistanceStation = filteredPositions.find(pos => {
                const distance = pos.distance || calculateDistance(REPEATER_CONFIG.lat, REPEATER_CONFIG.lon, pos.lat, pos.lon);
                return Math.abs(distance - maxDistance) < 0.01;
            });
            
            const widgetElement = document.getElementById('maxDistanceValue');
            if (maxDistanceStation) {
                widgetElement.innerHTML = `${maxDistance.toFixed(2)} km<br><small>${maxDistanceStation.callsign}</small>`;
            } else {
                widgetElement.textContent = `${maxDistance.toFixed(2)} km`;
            }
        }

        // Funci√≥n auxiliar para agregar nueva posici√≥n considerando filtros
        function addPositionWithFilter(position) {
            // Agregar a la lista completa
            allPositions.push(position);
            
            // Si no hay filtro activo o la posici√≥n pasa el filtro actual, agregarla a la vista
            if (currentFilter === 'all' || positionPassesCurrentFilter(position)) {
                addPosition(position);
            }
        }

        // Verificar si una posici√≥n pasa el filtro actual
        function positionPassesCurrentFilter(position) {
            const now = new Date();
            const posDate = new Date(position.timestamp);
            const todayStart = new Date(now.getFullYear(), now.getMonth(), now.getDate());
            
            switch (currentFilter) {
                case 'today':
                    return posDate >= todayStart;
                case 'yesterday':
                    const yesterdayStart = new Date(todayStart);
                    yesterdayStart.setDate(yesterdayStart.getDate() - 1);
                    return posDate >= yesterdayStart && posDate < todayStart;
                case 'last7days':
                    const last7DaysStart = new Date(todayStart);
                    last7DaysStart.setDate(last7DaysStart.getDate() - 7);
                    return posDate >= last7DaysStart;
                case 'custom':
                    const startDate = document.getElementById('startDate').value;
                    const endDate = document.getElementById('endDate').value;
                    if (startDate && endDate) {
                        const start = new Date(startDate + 'T00:00:00');
                        const end = new Date(endDate + 'T23:59:59');
                        return posDate >= start && posDate <= end;
                    }
                    return true;
                default:
                    return true;
            }
        }

        // Funci√≥n personalizada para cargar datos iniciales con filtros
        function loadInitialDataWithFilters() {
            fetch('/api/aprs/positions')
                .then(response => response.json())
                .then(data => {
                    if (data.data && Array.isArray(data.data)) {
                        allPositions = [...data.data]; // Guardar todas las posiciones
                        
                        console.log(`Cargadas ${data.data.length} posiciones iniciales`);
                        
                        // Asegurar que todo est√© listo antes de aplicar filtros
                        setTimeout(() => {
                            applyDateFilter();
                        }, 200);
                    }
                    
                    // Tambi√©n intentar cargar metadata desde el archivo JSON 
                    fetch('/logs/aprs-positions.json')
                        .then(response => response.json())
                        .then(jsonData => {
                            if (jsonData.metadata && jsonData.metadata.dateRange) {
                                setupDateRangeInputs(jsonData.metadata.dateRange);
                            }
                        })
                        .catch(error => {
                            console.log('Metadata no disponible desde JSON:', error.message);
                        });
                })
                .catch(error => {
                    console.error('Error cargando datos iniciales:', error);
                });
        }

        // Configurar inputs de fecha basado en el rango disponible
        function setupDateRangeInputs(dateRange) {
            const startDateInput = document.getElementById('startDate');
            const endDateInput = document.getElementById('endDate');
            
            if (dateRange.earliest) {
                const earliestDate = new Date(dateRange.earliest);
                startDateInput.min = earliestDate.toISOString().split('T')[0];
            }
            
            if (dateRange.latest) {
                const latestDate = new Date(dateRange.latest);
                endDateInput.max = latestDate.toISOString().split('T')[0];
            }
        }
    </script>
</body>
</html>