<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mapa APRS - VX200 RPT Controller</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css" />
    <style>
        #map {
            height: 70vh;
            width: 100%;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            position: relative;
        }
        .distance-widget {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(255, 255, 255, 0.95);
            padding: 8px 12px;
            border-radius: 6px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
            z-index: 1000;
            font-size: 0.85em;
            font-weight: 500;
            color: #495057;
            border-left: 3px solid #007bff;
            min-width: 140px;
        }
        .distance-widget .distance-value {
            color: #007bff;
            font-weight: bold;
        }
        .info-panel {
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            padding: 15px;
            margin-bottom: 20px;
        }
        .station-info {
            padding: 10px;
            background: #f8f9fa;
            border-radius: 5px;
            margin-bottom: 10px;
        }
        .status-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
        }
        .status-connected { background-color: #28a745; }
        .status-disconnected { background-color: #dc3545; }
        .beacon-status { 
            font-size: 0.9em;
            color: #6c757d;
        }
        .position-list {
            max-height: 300px;
            overflow-y: auto;
        }
        .position-item {
            padding: 8px 12px;
            border-bottom: 1px solid #e9ecef;
            cursor: pointer;
        }
        .position-item:hover {
            background-color: #f8f9fa;
        }
        .callsign {
            font-weight: bold;
            color: #007bff;
        }
        .timestamp {
            font-size: 0.8em;
            color: #6c757d;
        }
        .coordinates {
            font-size: 0.9em;
            color: #495057;
        }
        
        /* Estilo para el scroll del panel de detalles */
        #stationDetails::-webkit-scrollbar {
            width: 8px;
        }
        
        #stationDetails::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 4px;
        }
        
        #stationDetails::-webkit-scrollbar-thumb {
            background: #007bff;
            border-radius: 4px;
        }
        
        #stationDetails::-webkit-scrollbar-thumb:hover {
            background: #0056b3;
        }
        
        /* Mejorar espaciado en el panel de detalles */
        .station-detail-header {
            position: sticky;
            top: 0;
            background: white;
            padding-bottom: 10px;
            border-bottom: 1px solid #e9ecef;
            margin-bottom: 15px;
            z-index: 10;
        }
    </style>
</head>
<body>
    <nav class="navbar navbar-dark bg-primary">
        <div class="container-fluid">
            <span class="navbar-brand mb-0 h1">üì° VX200 RPT Controller - Mapa APRS</span>
            <div class="d-flex align-items-center">
                <a href="/" class="btn btn-outline-light btn-sm me-3">‚Üê Panel Principal</a>
                <span class="status-indicator" id="connectionStatus"></span>
                <span id="connectionText">Desconectado</span>
            </div>
        </div>
    </nav>

    <div class="container-fluid mt-3">
        <div class="row">
            <div class="col-md-8">
                <div class="info-panel">
                    <h5>üó∫Ô∏è Mapa de Posiciones APRS</h5>
                    <div id="map">
                        <div class="distance-widget" id="distanceWidget">
                            üìè Estaci√≥n m√°s lejana: <span class="distance-value" id="maxDistanceValue">0 km</span>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="col-md-4">
                <!-- Estado del Sistema APRS -->
                <div class="info-panel">
                    <h5>üì° Estado APRS</h5>
                    <div id="aprsStatus">
                        <div class="d-flex justify-content-between">
                            <span>TNC:</span>
                            <span id="tncStatus" class="text-muted">Desconocido</span>
                        </div>
                        <div class="d-flex justify-content-between">
                            <span>Callsign:</span>
                            <span id="callsign" class="text-muted">-</span>
                        </div>
                        <div class="d-flex justify-content-between">
                            <span>Beacons enviados:</span>
                            <span id="beaconsSent" class="text-muted">0</span>
                        </div>
                        <div class="d-flex justify-content-between">
                            <span>Posiciones recibidas:</span>
                            <span id="positionsReceived" class="text-muted">0</span>
                        </div>
                    </div>
                    <div class="mt-3">
                        <button class="btn btn-primary btn-sm" onclick="sendManualBeacon()">Enviar Beacon</button>
                        <button class="btn btn-secondary btn-sm" onclick="refreshMap()">Actualizar</button>
                    </div>
                </div>

                <!-- Lista de Estaciones -->
                <div class="info-panel">
                    <h5>üìã Estaciones Recibidas (<span id="stationCount">0</span>)</h5>
                    <div class="position-list" id="positionsList">
                        <div class="text-center text-muted p-3">
                            No hay posiciones recibidas
                        </div>
                    </div>
                </div>

                <!-- Informaci√≥n Detallada -->
                <div class="info-panel" id="detailPanel" style="display: none;">
                    <h5>‚ÑπÔ∏è Informaci√≥n de Estaci√≥n</h5>
                    <div id="stationDetails" style="max-height: 400px; overflow-y: auto; padding-right: 5px;"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Scripts -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"></script>
    <script src="/socket.io/socket.io.js"></script>
    
    <script>
        // Variables globales
        let map;
        let socket;
        let markers = {};
        let repeaterMarker;
        let positions = [];
        let coverageCircle = null;
        let maxDistance = 0;
        
        // Configuraci√≥n del repetidor (deber√≠an venir del servidor)
        const REPEATER_CONFIG = {
            callsign: 'YOSHUA',
            lat: -32.9082647,
            lon: -68.8162689,
            elevation: 775,
            name: 'VX200 RPT Controller - Guaymall√©n'
        };
        
        // Funci√≥n para calcular distancia (Haversine)
        function calculateDistance(lat1, lon1, lat2, lon2) {
            const R = 6371; // Radio de la Tierra en km
            const dLat = toRadians(lat2 - lat1);
            const dLon = toRadians(lon2 - lon1);
            const a = 
                Math.sin(dLat/2) * Math.sin(dLat/2) +
                Math.cos(toRadians(lat1)) * Math.cos(toRadians(lat2)) * 
                Math.sin(dLon/2) * Math.sin(dLon/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            return R * c;
        }
        
        function toRadians(degrees) {
            return degrees * (Math.PI/180);
        }
        
        // Inicializar aplicaci√≥n
        document.addEventListener('DOMContentLoaded', function() {
            initializeMap();
            initializeSocket();
            loadInitialData();
        });
        
        // Inicializar mapa
        function initializeMap() {
            map = L.map('map').setView([REPEATER_CONFIG.lat, REPEATER_CONFIG.lon], 12); // Zoom inicial m√°s cercano
            
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '¬© OpenStreetMap contributors'
            }).addTo(map);
            
            // Agregar marcador del repetidor
            repeaterMarker = L.marker([REPEATER_CONFIG.lat, REPEATER_CONFIG.lon], {
                icon: L.icon({
                    iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-red.png',
                    shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png',
                    iconSize: [25, 41],
                    iconAnchor: [12, 41],
                    popupAnchor: [1, -34],
                    shadowSize: [41, 41]
                })
            }).addTo(map);
            
            repeaterMarker.bindPopup(`
                <b>${REPEATER_CONFIG.callsign}</b><br>
                ${REPEATER_CONFIG.name}<br>
                <small>Repetidor Base</small>
            `);
        }
        
        // Inicializar WebSocket
        function initializeSocket() {
            socket = io();
            
            socket.on('connect', function() {
                updateConnectionStatus(true);
                console.log('Conectado al servidor');
            });
            
            socket.on('disconnect', function() {
                updateConnectionStatus(false);
                console.log('Desconectado del servidor');
            });
            
            socket.on('aprs_position', function(data) {
                console.log('Nueva posici√≥n APRS:', data);
                addPosition(data.data);
            });
            
            socket.on('aprs_beacon', function(data) {
                console.log('Beacon APRS enviado:', data);
                updateBeaconCount();
            });
            
            socket.on('aprs_status', function(data) {
                console.log('Estado APRS actualizado:', data);
                updateAPRSStatus(data.data);
            });
        }
        
        // Cargar datos iniciales
        async function loadInitialData() {
            try {
                // Cargar posiciones existentes
                const positionsResponse = await fetch('/api/aprs/positions');
                if (positionsResponse.ok) {
                    const positionsData = await positionsResponse.json();
                    if (positionsData.success) {
                        positions = positionsData.data;
                        renderPositions();
                        // Actualizar marcadores de posiciones existentes
                        positions.forEach(pos => updatePositionMarker(pos));
                        updateCoverageCircle();
                    }
                }
                
                // Cargar estado APRS
                const statusResponse = await fetch('/api/aprs/status');
                if (statusResponse.ok) {
                    const statusData = await statusResponse.json();
                    if (statusData.success) {
                        updateAPRSStatus(statusData.data);
                    }
                }
            } catch (error) {
                console.error('Error cargando datos iniciales:', error);
            }
        }
        
        // Actualizar estado de conexi√≥n
        function updateConnectionStatus(connected) {
            const statusElement = document.getElementById('connectionStatus');
            const textElement = document.getElementById('connectionText');
            
            if (connected) {
                statusElement.className = 'status-indicator status-connected';
                textElement.textContent = 'Conectado';
            } else {
                statusElement.className = 'status-indicator status-disconnected';
                textElement.textContent = 'Desconectado';
            }
        }
        
        // Agregar nueva posici√≥n
        function addPosition(position) {
            // Buscar si ya existe
            const existingIndex = positions.findIndex(p => p.callsign === position.callsign);
            
            if (existingIndex >= 0) {
                positions[existingIndex] = position;
            } else {
                positions.push(position);
            }
            
            renderPositions();
            updatePositionMarker(position);
            updateCoverageCircle();
        }
        
        // Renderizar lista de posiciones
        function renderPositions() {
            const listContainer = document.getElementById('positionsList');
            const countElement = document.getElementById('stationCount');
            
            countElement.textContent = positions.length;
            
            if (positions.length === 0) {
                listContainer.innerHTML = '<div class="text-center text-muted p-3">No hay posiciones recibidas</div>';
                return;
            }
            
            // Agrupar por callsign y mostrar la m√°s reciente de cada uno primero
            const groupedByCallsign = {};
            positions.forEach(pos => {
                if (!groupedByCallsign[pos.callsign]) {
                    groupedByCallsign[pos.callsign] = [];
                }
                groupedByCallsign[pos.callsign].push(pos);
            });
            
            // Ordenar cada grupo por timestamp y tomar la m√°s reciente para el listado principal
            const sortedPositions = Object.values(groupedByCallsign).map(group => {
                const sorted = group.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
                return sorted[0]; // Tomar la m√°s reciente de cada callsign
            }).sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
            
            const html = sortedPositions.map(pos => {
                const timeAgo = getTimeAgo(new Date(pos.timestamp));
                const distance = pos.distance || calculateDistance(REPEATER_CONFIG.lat, REPEATER_CONFIG.lon, pos.lat, pos.lon);
                const allPositionsCount = groupedByCallsign[pos.callsign].length;
                
                return `
                    <div class="position-item" onclick="showStationDetails('${pos.callsign}')">
                        <div class="callsign">${pos.callsign}${allPositionsCount > 1 ? ` (${allPositionsCount} ubicaciones)` : ''}</div>
                        <div class="coordinates">${pos.lat.toFixed(4)}, ${pos.lon.toFixed(4)} ${allPositionsCount > 1 ? '(m√°s reciente)' : ''}</div>
                        <div class="text-info" style="font-size: 0.85em;">üìè ${distance.toFixed(2)} km</div>
                        <div class="timestamp">${timeAgo}</div>
                        ${pos.comment ? `<div class="text-muted" style="font-size: 0.8em;">${pos.comment}</div>` : ''}
                    </div>
                `;
            }).join('');
            
            listContainer.innerHTML = html;
        }
        
        // Actualizar marcador en el mapa
        function updatePositionMarker(position) {
            // Usar key √∫nica para cada ubicaci√≥n diferente
            const key = `${position.callsign}_${position.locationId || Date.now()}`;
            
            // Solo remover si es exactamente la misma ubicaci√≥n
            // (No remover otras ubicaciones del mismo callsign)
            
            // Crear nuevo marcador
            const marker = L.marker([position.lat, position.lon], {
                icon: L.icon({
                    iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-blue.png',
                    shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png',
                    iconSize: [25, 41],
                    iconAnchor: [12, 41],
                    popupAnchor: [1, -34],
                    shadowSize: [41, 41]
                })
            }).addTo(map);
            
            const timeAgo = getTimeAgo(new Date(position.timestamp));
            const distance = position.distance || calculateDistance(REPEATER_CONFIG.lat, REPEATER_CONFIG.lon, position.lat, position.lon);
            marker.bindPopup(`
                <b>${position.callsign}</b><br>
                ${position.lat.toFixed(4)}, ${position.lon.toFixed(4)}<br>
                <span style="color: #007bff;">üìè ${distance.toFixed(2)} km</span><br>
                <small>${timeAgo}</small>
                ${position.comment ? `<br><i>${position.comment}</i>` : ''}
                ${position.symbol ? `<br><small>${position.symbol}</small>` : ''}
            `);
            
            markers[key] = marker;
            
            // Guardar referencia por callsign para navegaci√≥n
            if (!markers[position.callsign]) {
                markers[position.callsign] = [];
            }
            if (Array.isArray(markers[position.callsign])) {
                markers[position.callsign].push(marker);
            } else {
                // Convertir marcador √∫nico a array
                const oldMarker = markers[position.callsign];
                markers[position.callsign] = [oldMarker, marker];
            }
        }
        
        // Mostrar detalles de estaci√≥n
        function showStationDetails(callsign) {
            const stationPositions = positions.filter(p => p.callsign === callsign);
            if (stationPositions.length === 0) return;
            
            const detailPanel = document.getElementById('detailPanel');
            const detailsContainer = document.getElementById('stationDetails');
            
            // Mostrar informaci√≥n de todas las ubicaciones de esta estaci√≥n
            const positionsHtml = stationPositions.map((position, index) => {
                const timeAgo = getTimeAgo(new Date(position.timestamp));
                const distance = position.distance || calculateDistance(REPEATER_CONFIG.lat, REPEATER_CONFIG.lon, position.lat, position.lon);
                
                return `
                    <div class="station-info" style="margin-bottom: 10px; ${index === 0 ? 'border: 2px solid #007bff;' : ''}">
                        <h6>${position.callsign} ${index > 0 ? `(Ubicaci√≥n #${index + 1})` : '(M√°s reciente)'}</h6>
                        <div><strong>Ubicaci√≥n:</strong> ${position.lat.toFixed(6)}, ${position.lon.toFixed(6)}</div>
                        <div><strong>Distancia:</strong> <span style="color: #007bff;">üìè ${distance.toFixed(2)} km</span></div>
                        <div><strong>√öltima actualizaci√≥n:</strong> ${timeAgo}</div>
                        <div><strong>Timestamp:</strong> ${new Date(position.timestamp).toLocaleString()}</div>
                        ${position.comment ? `<div><strong>Comentario:</strong> ${position.comment}</div>` : ''}
                        ${position.symbol ? `<div><strong>S√≠mbolo:</strong> ${position.symbol}</div>` : ''}
                        <button onclick="focusOnPosition('${callsign}', ${position.lat}, ${position.lon})" class="btn btn-sm btn-outline-primary">
                            üìç Ver en mapa
                        </button>
                    </div>
                `;
            }).join('');
            
            detailsContainer.innerHTML = `
                <div class="station-detail-header">
                    <strong>üì° ${callsign}</strong> - ${stationPositions.length} ubicacion${stationPositions.length > 1 ? 'es' : ''} registrada${stationPositions.length > 1 ? 's' : ''}
                    <div style="font-size: 0.9em; color: #6c757d; margin-top: 5px;">
                        Haz clic en "üìç Ver en mapa" para navegar a cada ubicaci√≥n
                    </div>
                </div>
                <div style="padding-bottom: 10px;">
                    ${positionsHtml}
                </div>
            `;
            
            detailPanel.style.display = 'block';
            
            // Centrar en la posici√≥n m√°s reciente y ajustar zoom para ver todas las ubicaciones
            const mostRecent = stationPositions[0];
            focusOnPosition(callsign, mostRecent.lat, mostRecent.lon);
        }
        
        // Nueva funci√≥n para enfocar en una posici√≥n espec√≠fica
        function focusOnPosition(callsign, lat, lon) {
            // Centrar mapa en la posici√≥n con zoom cercano
            map.setView([lat, lon], 15, {
                animate: true,
                duration: 1.0
            });
            
            // Buscar y abrir popup del marcador correspondiente
            Object.keys(markers).forEach(key => {
                if (key.startsWith(callsign + '_')) {
                    const marker = markers[key];
                    const markerPos = marker.getLatLng();
                    // Verificar si es la posici√≥n correcta (tolerancia de 0.0001 grados ~10m)
                    if (Math.abs(markerPos.lat - lat) < 0.0001 && Math.abs(markerPos.lng - lon) < 0.0001) {
                        marker.openPopup();
                    }
                }
            });
        }
        
        // Actualizar estado APRS
        function updateAPRSStatus(status) {
            document.getElementById('tncStatus').textContent = status.tncConnected ? 'Conectado' : 'Desconectado';
            document.getElementById('callsign').textContent = status.config.callsign || '-';
            document.getElementById('beaconsSent').textContent = status.stats.beaconsSent || 0;
            document.getElementById('positionsReceived').textContent = status.stats.positionsReceived || 0;
            
            const tncElement = document.getElementById('tncStatus');
            tncElement.className = status.tncConnected ? 'text-success' : 'text-danger';
        }
        
        // Enviar beacon manual
        async function sendManualBeacon() {
            try {
                const response = await fetch('/api/aprs/beacon', {
                    method: 'POST'
                });
                const data = await response.json();
                
                if (data.success) {
                    alert('Beacon APRS enviado correctamente');
                } else {
                    alert('Error: ' + data.message);
                }
            } catch (error) {
                console.error('Error enviando beacon:', error);
                alert('Error enviando beacon');
            }
        }
        
        // Actualizar mapa
        function refreshMap() {
            loadInitialData();
        }
        
        // Actualizar c√≠rculo de cobertura basado en estaciones m√°s lejanas
        function updateCoverageCircle() {
            if (positions.length === 0) {
                // Si no hay posiciones, remover el c√≠rculo
                if (coverageCircle) {
                    map.removeLayer(coverageCircle);
                    coverageCircle = null;
                }
                maxDistance = 0;
                updateDistanceWidget();
                return;
            }
            
            // Encontrar la distancia m√°xima considerando todas las posiciones hist√≥ricas
            let newMaxDistance = 0;
            positions.forEach(pos => {
                const distance = pos.distance || calculateDistance(REPEATER_CONFIG.lat, REPEATER_CONFIG.lon, pos.lat, pos.lon);
                if (distance > newMaxDistance) {
                    newMaxDistance = distance;
                }
            });
            
            // Solo actualizar si la distancia cambi√≥ significativamente
            if (Math.abs(newMaxDistance - maxDistance) > 0.1 || maxDistance === 0) {
                maxDistance = newMaxDistance;
                
                // Remover c√≠rculo anterior
                if (coverageCircle) {
                    map.removeLayer(coverageCircle);
                }
                
                // Crear nuevo c√≠rculo con margen del 10%
                const radiusKm = maxDistance * 1.1;
                const radiusMeters = radiusKm * 1000;
                
                coverageCircle = L.circle([REPEATER_CONFIG.lat, REPEATER_CONFIG.lon], {
                    color: '#007bff',
                    fillColor: '#007bff',
                    fillOpacity: 0.1,
                    radius: radiusMeters,
                    weight: 2,
                    dashArray: '5, 5'
                }).addTo(map);
                
                coverageCircle.bindPopup(`
                    <b>üì° Rango de Recepci√≥n</b><br>
                    Radio: <span style="color: #007bff;">${radiusKm.toFixed(2)} km</span><br>
                    Estaci√≥n m√°s lejana: <span style="color: #007bff;">${maxDistance.toFixed(2)} km</span><br>
                    <small>Basado en ${positions.length} estacion${positions.length > 1 ? 'es' : ''} recibida${positions.length > 1 ? 's' : ''}</small>
                `);
                
                console.log(`C√≠rculo de cobertura actualizado: ${radiusKm.toFixed(2)} km`);
                
                // Ajustar zoom autom√°ticamente basado en el radio del c√≠rculo
                adjustMapZoom(radiusKm);
            }
            
            // Actualizar widget de distancia
            updateDistanceWidget();
        }
        
        // Actualizar widget de distancia m√°xima
        function updateDistanceWidget() {
            const distanceWidget = document.getElementById('maxDistanceValue');
            if (distanceWidget) {
                if (maxDistance > 0) {
                    distanceWidget.textContent = `${maxDistance.toFixed(2)} km`;
                    document.getElementById('distanceWidget').style.display = 'block';
                } else {
                    document.getElementById('distanceWidget').style.display = 'none';
                }
            }
        }
        
        // Ajustar zoom del mapa basado en el radio del c√≠rculo de cobertura
        function adjustMapZoom(radiusKm) {
            // Calcular zoom apropiado basado en el radio
            // F√≥rmula: zoom m√°s alto para c√≠rculos peque√±os, zoom m√°s bajo para c√≠rculos grandes
            let targetZoom;
            
            if (radiusKm <= 0.5) {
                targetZoom = 15; // Muy cerca para c√≠rculos < 500m
            } else if (radiusKm <= 1.0) {
                targetZoom = 14; // Cerca para c√≠rculos < 1km
            } else if (radiusKm <= 2.0) {
                targetZoom = 13; // Medio para c√≠rculos < 2km
            } else if (radiusKm <= 5.0) {
                targetZoom = 12; // Moderado para c√≠rculos < 5km
            } else if (radiusKm <= 10.0) {
                targetZoom = 11; // Alejado para c√≠rculos < 10km
            } else {
                targetZoom = 10; // Muy alejado para c√≠rculos grandes
            }
            
            
            // Aplicar zoom suavemente
            map.setView([REPEATER_CONFIG.lat, REPEATER_CONFIG.lon], targetZoom, {
                animate: true,
                duration: 1.0
            });
        }

        // Utilidad para calcular tiempo transcurrido
        function getTimeAgo(date) {
            const now = new Date();
            const diffMs = now - date;
            const diffMins = Math.floor(diffMs / 60000);
            const diffHours = Math.floor(diffMins / 60);
            const diffDays = Math.floor(diffHours / 24);
            
            if (diffDays > 0) return `hace ${diffDays} d√≠a${diffDays > 1 ? 's' : ''}`;
            if (diffHours > 0) return `hace ${diffHours} hora${diffHours > 1 ? 's' : ''}`;
            if (diffMins > 0) return `hace ${diffMins} minuto${diffMins > 1 ? 's' : ''}`;
            return 'hace menos de 1 minuto';
        }
    </script>
</body>
</html>